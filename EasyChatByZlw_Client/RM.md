1、向服务器发送登录信息后，就是在Client.java中的login()方法执行后，
登录成功后，第一步就是服务器会将更新后的用户列表id发送给客户端，所以
客户端需要处理接收。

2、在Client类中，线程中的utils.ReadPkg()方法会一直处于监听信息的状态，
    它收到字符串chat_re信息后，将字符串chat_re反序列化为总信息对象Message，
    然后根据Message的type属性匹配此信息是什么类型的信息，这个信息仍是字符串
    类型，需要在根据type的类型反序列化成具体的消息对象。

3、根据在Client类中，匹配到的信息类型，调用Client_chatFrame类中的方法进行
    响应消息的处理。
    在Client_chatFrame类中，三种主要方法的作用：

    setDisMess()方法:如果匹配到的SmsMes类型的信息，说明是信息类型通话消息，
    会那么在setDisMess()方法中，将Message对象的data属性字符串反序列化为
    SmsMes对象，然后将SmsMes对象的Content属性（信息本身）进行展示即可。

    setDisUsers()方法: 当客户端第一次登录，在服务器端接收到用户想要登录时，就
    会将自己获知的用户列表发送给此用户，此用户根据”LoginResMes“的消息类型进入
    到setDisUsers方法中。这个方法中，首先将字符串反序列化为LoginResMes类型
    的对象，这个对象中UsersId[]数组保存的就是在线用户的id列表，在拿到列表后。
    判断这个UsersId是不是只有一个用户，有一个用户说明只有自己本客户端一个人是
    登录状态。如果还有其他用户（UserId.length > 1），就将其他用户的用户名
    加入到本地的在线用户名列表client.username_online中，再将其他用户的用户
    id加到本地用户id列表client.clientuserid中,并将用户名放到String数组中，
    放到jlt_disUsers面板中展示.
    
    setUpDownUser()方法: 当有用户下线/上线时，会给服务器发送下线/上线通知，
    那么服务器端就将服务器端保留的在线用户列表中删除此用户的在线（或添加用户在线）。
    并将此用户的下线/上线通知：NotifyUserStatusMes类型的消息发送每一个在线的
    客户端，客户端收到后，匹配在Client类中，匹配到的NotifyUserStatusMes信息
    类型，就会进入setUpDownUser()方法。首先将字符串反序列化为NotifyUserStatusMes
    类型的对象，然后判断这个对象中，Status标记的是离线还是登录。
      如果Status等于1说明通知的是新上线的用户，如果Status为0，说明是通知刚下线
    的用户。如果Status为1，判断NotifyUserStatusMes中，携带的属性UserId是不
    是已经在本地的用户列表中，如果在说明不用再添加了（这也说明了本地用户列表更新迟钝）
    ，如果不在，就将此用户的UserId和用户名加入到本地的用户id列表client.clientuserid
    和本地的在线用户名列表client.username_online中。
        如果Status为 0，判断NotifyUserStatusMes中，携带的属性UserId是不
    是在本地的用户列表中，如果不在说明本地用户列表更新迟钝。如果在，就考虑删除，
    首先判断本地的在线用户列表是不是只剩下一个人，如果是，就观察客户端开启的单聊窗口
    的map对象不是为空，因为只剩下这一个人了，这次通知将要下线的人肯定也是这个人了，
    所以可以将本地存在单聊窗口关闭。最后将客户端的用户列表清空。如果本地的用户列表不
    为空，因为本次通知的只是一人下线，所以找到这个人，删除本地的在线用户名列表
    client.username_online的此用户名字，以及本地用户id列表client.clientuserid
    中此用户的id.如果开启的还有与此用户的单聊窗口，也一起关闭。
    
4、客户端和服务器两者，他们在发送数据的时候，都是先发送此数据的长度，然后再发送此数据的本身，
    这样做1、是为了确保检查实际接收的数据是不是与想要发送的数据长度一致。2、因为服务器和客
    户端两者之间使用的是byte数组形式的数组进行数据传递，即服务器发送的byte数组，客户端
    发送的也是byte[]数组，一位就是一个字节，这一个字节打印输出时是一个-127 —— +127的十进
    制的数，客户端在接收服务器端发送的byte数组的数据时，必须将byte[]数组转为实际的字符，所
    以就需要String的构造方法:
    new String(byte bytes[], int offset, int length, String charsetName)
    将byte[]数组，根据需要转换的起始位置，需要转换的长度，和需要转为的编码格式进行转化。如果
    不判断实际接收的长度与想要发送的长度是否一直，而直接去转换就会转换错误，可能就导致信息类型不匹配。
    对于客户端接收消息的方法：ReadPkg()，因为先接收此数据的长度，然后再接收此数据的本身，服务器以小端
    规则发送的数据的长度，比如长度是89，那么服务器发送的就是[89,0,0,0]（注意89在byte[]数组中以二进
    制存在）,客户端接收到[89,0,0,0]后，就要以小端规则去读取，就是使用bytesToIntLowAhead()方法,
    如果不使用bytesToIntLowAhead()方法去转为int类型，就是默认以大端规则读取，读取得到的就是：
    89(二进制)00000000000000000，表示的非常大的整数。

    对于客户端发送数据的方法：WritePkg()。首先需要明白，在服务器端go语言中，一个汉字占3 byte的大小，
    如果对一个汉字，如：张，使用go语言的内置函数len()去判断这个汉字的长度时返回len("张")为3，一个
    全中文的字符串也是字符串的字符个数 乘 3 的长度，一个中文的标点也是3的长度，但是在Java中，判断一个
    一个中文字符的长度就是 1 。所以如果直接将字符串长度发送给服务器，服务器是不能反序列化的，会出错。
    就需要客户端将需要发送的字符串中，判断中文字符和中文标点的个数，然后给服务器发送:原字符串的长度 + 
    （中文字符和中文标点的个数的二倍）才可以。判断一个字符串中中文字符和中文标点的个数的函数是：FilterChinese
    类。MessageUtils类是用来将需要发送的信息封装成对应的Json字符串，省去某一个地方需要发送信息时，又需要
    包装成对应的信息类型，将转为json字符串，再将此json字符串包装成Message对象，再转为json字符串的过程。

5、感悟：1、Java和go中，一个byte就是8位。Java中一个char类型是两个字节，刚好可以存储一个 汉字 。
        go中一个汉字需要三个字节存储。
    

    
